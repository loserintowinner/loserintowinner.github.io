---
layout: post
title: 【JAVA】并发编程之 JUC 详解
# toc: true
# typora-root-url: ../assets
---

  <!-- * awsl  //星号后可能需要空一格，后面需要加上一段文本（用途不明，但是非加不可）
  {:toc} -->

相对于传统的单线程，多线程能够在操作系统多核配置的基础了更好地利用服务器的多个CPU资源，使程序运行起来更加高效。Java通过对多线程的支持，在一个进程内并发执行多个线程，每个线程都并行执行不同的任务，以满足编写高并发程序的需求。



# Java线程基本知识

## Java线程的创建方式

常见的Java线程的创建方式分别为**继承Thread类、实现Runnnable接口、通过ExecutorService和Callable<Class>实现有返回值的线程、基于线程池**

#### 一、继承Thread类

Thread类实现了Runnable接口并定义了操作线程的一些方法，我们可以通过继承Thread类的方式

```java
	//1:通过继承Thread类创建NewThread对象
	public class NewThread extends Thread{
    	public void run(){
        	System.out.println("create a thread by extends Thread");
    	}
	}
	//2:实例化一个NewThread线程对象
	NewThread newThread = new NewThread();
	//3:调用start方法启动NewThread线程
	newThread.start();
```

#### 二、实现Runnable接口

基于Java编程规范，如果子类已经继承（extends）了一个类，就无法再继承Thread类。此时就可以通过实现Runnable接口创建线程。

```java
	//1:通过实现Runnable接口创建childrenClassThread对象
	public class ChildrenClassThread extends SuperClass implements Runnable{
    	public void run(){
        	System.out.println("create a thread by implements Runnable");
    	}
	}
	//2:实例化一个childrenClassThread对象
	ChildrenClassThread childrenClassThread = new ChildrenClassThread();
	//3:创建一个线程对象并为其传入已经实例化好的childrenThread对象
	Thread thread = new Thread(childrenClassThread);
	//4、调用start方法启动线程
	thread.start();
```



##### 原理之 Thread 与 Runnable 的关系

分析 Thread 的源码，理清它与 Runnable 的关系：

**class Thread implements Runnable**

​		事实上，在传入一个实现 Runnable 的线程实例 target 给 Thread 后，Thread 的 run 方法在执行时就会调用 target.run 方法 并执行该线程具体的实现逻辑。在 JDK 源码中，run 方法的实现代码如下：

```java
	@Override
	public void run(){
		if(target != null){
			target.run();
		}
	}
```

**小结**

- 方法1 是把线程和任务合并在了一起，方法2 是把线程和任务分开了
- 用 Runnable 更容易与线程池等高级 API 配合
- 用 Runnable 让任务类脱离了 Thread 继承体系，更灵活



#### 三、通过 ExecutorService 和 Callable <Class> 接口实现有返回值的线程 

有时，我们需要在主线程中开启多个子线程并发执行一个任务，然后收集各个线程返回的结果并将最终结果汇总起来，这时就要用到Callable接口。

```java
	//1:通过实现 Callable 接口创建 MyCallable 线程
	public class MyCallable implements Callable<String>{
        private String name;
        public MyCallable(String name){//通过构造函数为线程传递函数，以定义线程的名称
            this.name = name;
        }
        @Override
        public String call() throw Exception{//call方法内为线程实现逻辑
            return name;
        }
    }
	//2:创建一个固定大小为 5 的线程池
	ExecutorService pool = Executors.newFixedThreadPool(5);
	//3:创建多个有返回值的任务列表list
	List<Future> list = new ArrayList<Future>();
	for(int i=0;i<5;i++){
        //4:创建一个有返回值的线程实例
        Callable c = new MyCallable(i+"");
        //5:提交线程，获取Future对象并将其保存在 Future List 中
        Future future = pool.submit(c);
        System.out.println("submit a callable thread:"+i);
        list.add(future);
    }
	//6:关闭线程池，等待线程执行结束
	poll.shutdown();
	//7:遍历所有线程的运行结果
	for(Future f:list){
        //从Future对象上获取任务的返回值，并将结果输出到控制台
        System.out.println("get the result from callable thread:"+
                          f.get().toString());
    }
```



##### Callable和Runnable的区别

​	(1) Callable 规定的方法是 call (), Runnable 规定的方法是 run().

​	(2) Callable 的任务执行后可返回值，而 Runnable 的任务是不能返回值的

​	(3) call 方法可以抛出异常，run 方法不可以 必须在内部处理，不能抛出

​	(4) 运行 Callable 任务可以拿到一个 Future 对象，Future 表示异步计算的结果。(PS: 特别注意,executorService.submit(Runnable task) 也会返回future, 但是没有future的效果 )

#### **四、基于线程池**

```java
	//1:创建大小为10的线程池
	ExecutorService threadPool = Executors.newFixedThreadPool(10);
	//2:提交多个线程任务并执行
	threadPool.execute(new Runnable(){
        @Override
        public void run(){
            System.out.println(Thread.currentThread().getName()+"is Running");
        }
    })
```





## 线程的生命周期

在JVM源码中将线程的生命周期分为**新建（New）、可运行（Runnable）、阻塞（Blocked）、等待（Waiting）、超时等待（Timed_Waiting）和终止（Terminated）这6种状态**。

![img](assets/JUC.assets/20200715134934917-cnblogs.png)

其流程如下：

（1）调用 new 方法创建一个线程，这时线程处于新建状态。

（2）调用 start方法启动一个线程，这时线程处于可运行状态。可运行状态又分为就绪状态（Ready）和运行中（Running）两种状态。处于就绪状态的线程等待线程获取 CPU 资源，在等待其获取 CPU 资源后，线程会调用 run 方法进入运行中状态；处于运行中状态的线程在调用 yield 方法或失去处理器资源时，会再次进入就绪状态。

（3）处于运行中状态的线程在**执行 sleep 方法、I/O阻塞、等待同步锁、等待通知、suspend 方法等后，会挂起并进入阻塞状态**。处于阻塞状态的线程由于出现 sleep 时间已到、I/O方法返回、获得同步锁、收到通知、调用 resume 方法等情况，会再次进入可运行状态中的就绪状态，等待 CPU 时间片的轮询。该线程在获取 CPU 资源后，会再次进入运行中状态。

（4）线程在**调用 Object.wait（）、Object.join（）、LockSupport.park（）后会进入等待状态**。处于等待状态的线程在调用 Object.notify（）、Object.notifyAll（）.LockSupport.unpark（Thread）后会再次进入可运行状态。

（5）处于可运行状态的线程在调用 **Thread.sleep（long）、Object.wait（long）、Thread.join（long）、LockSupport.parkNanos（）、LockSupport.parkUntil（）**后会进入超时等待状态。当处于超时等待状态的线程出现超时时间到、等待进入 synchronized 方法、等待进入 synchronized 代码块或者调用 Object.notify（）、Object.notifyAll（）、LockSupport.unpark（Thread）后会再次进入可运行状态。

（6）处于可运行状态的线程，在调用 run 方法或 call 方法正常执行完成、调用 stop 方法停止线程或者程序执行错误导致异常退出时，会进入终止状态。（ stop 不推荐使用，该方式会瞬间释放线程占用的同步对象锁，导致锁混乱和死锁）









## 线程的基本方法

#### 线程等待：wait方法

调用 wait 方法的线程会进入 Waiting 状态，只有等到其他线程的通知或被中断后才会返回。需要注意的是，在调用 wait 方法后会释放对象的锁，因此 wait 方法一般被用到同步方法或同步代码块中。

#### 线程睡眠：sleep方法

sleep方法不会释放当前占用的锁，会导致线程进入超时等待状态；而wait方法会导致当前线程进入等待状态。

1.  调用 sleep 会让当前线程从 *Running* 进入 *Timed Waiting* 状态（阻塞）
2.  其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException
3.  睡眠结束后的线程未必会立刻得到执行
4.  建议用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性

#### 线程让步：yield方法

调用 yield 方法会使当前线程让出（释放）CPU 时间片，与其他线程一起重新竞争 CPU 时间片。在一般情况下，优先级高的线程更有可能竞争到 CPU 时间片，但这不是绝对的，有的操作系统对线程的优先级并不敏感。

1. 调用 yield 会让当前线程从 *Running* 进入 *Ready* 状态，然后调度执行其它线程
2. 具体的实现依赖于操作系统的任务调度器

```java
	Runnable task1 = () -> {
 		int count = 0;
 		for (;;) {
 			System.out.println("---->1 " + count++);
 		}
	};
	Runnable task2 = () -> {
 		int count = 0;
 		for (;;) {
 			// Thread.yield();
 			System.out.println(" ---->2 " + count++);
 		}
	};
	Thread t1 = new Thread(task1, "t1");
	Thread t2 = new Thread(task2, "t2");
	// t1.setPriority(Thread.MIN_PRIORITY);
	// t2.setPriority(Thread.MAX_PRIORITY);
	t1.start();
	t2.start();
```



#### 线程中断：interrupt方法

interrupt 方法用于向线程发送一个终止通知信号，会影响该线程内部的一个中断标识位，线程本身并不会因为调用了 interrupt 方法而改变状态（阻塞、终止等）。状态的具体变化需要等待接收到中断标识的程序的最终处理结果来判定。对 interrupt 方法的理解需要注意如下4个核心点：

- [ ] 调用 interrupt 方法并不会中断一个正在运行的线程，也就是说处于运行状态的线程并不会因为调用了 interrupt 方法而终止，仅仅改变了内部维护的中断标识位而已。具体的 JDK 源码如下：

```java
	// interrupted 返回 中断标识符 并 清除
	public static boolean interrupted(){
        return currentThread().isInterrupted(true);
    }
	// isInterrupted 不清除中断标识符 
	public boolean isInterrupted(){
        return isInterrupted(false);
    }
```

- [ ] 如果因为调用 sleep 方法使线程处于超时等待状态。则这时调用 interrput 方法会抛出 InterruptedException 异常，使线程提前结束超时等待状态。
- [ ] 许多声明抛出 InterruptedException的方法如 Thread.sleep（long mills），在抛出异常前都会清除中断标识位，所以在抛出异常后调用 isInterrupted 方法将会返回 false。
- [ ] 中断状态是线程固有的一个标识位，可以通过此标识位安全终止线程。比如，在想终止一个线程时，可以先调用该线程的 interrupt 方法，然后在线程的 run 方法中根据该线程的 isInterrupted 方法的返回状态值安全终止线程。

```java
	public class SafeInterruptThread extends Thread {
        @Override
        public void run(){
            if(!Thread.currentThread().isInterrupted()){
                try{
                    //1:这里处理正常的线程业务逻辑
                    sleep(10);
                }catch(InterruptedException e){
                    Thread.currentThread().interrput(); //重新设置中断标识
                }
            }
            if(!Thread.currentThread().isInterrupted()){
                //2:处理线程结束前必要的一些资源释放和清理工作，比如释放锁、
                //存储数据到持久化层、发出异常通知等，用于实现线程的安全退出
                sleep(10);
            }
        }
    }
	//3:定义一个可安全退出的线程
	SafeInterruptThread thread = new SafeInterruptThread();
	//4:安全退出线程
	thread.interrupt();
```

#### 线程加入：join 方法

join 方法用于等待其他线程终止，如果在当前线程中调用一个线程的 join 方法，则当前线程会转为阻塞状态，等到另一个线程结束，当前线程再有阻塞状态转为就绪状态，等待获取 CPU 的使用权。在很多情况下，主线程生成并启动了子线程，需要等到子线程返回结果并收集和处理再退出，这时就要用到 join 方法，具体的使用方法如下：

```java
	static int r1 = 0;
	static int r2 = 0;
	public static void main(String[] args) throws InterruptedException {
 		test3();
	}
	public static void test3() throws InterruptedException {
 		Thread t1 = new Thread(() -> {
 			sleep(1);
 			r1 = 10;
 		});
 		long start = System.currentTimeMillis();
 		t1.start();

 		// 线程执行结束会导致 join 结束
 		t1.join(1500);
 		long end = System.currentTimeMillis();
 		log.debug("r1: {} r2: {} cost: {}", r1, r2, end - start);
	}
```

#### 线程唤醒：notify方法

Object 类有个 notify 方法，用于唤醒在此对象监视器上等待的一个线程，如果所有线程都在此对象上等待，则会选择唤醒其中一个线程，唤醒时选择时任意的。被唤醒的线程将以常规方式与该对象上主动同步的其他线程竞争。类似的方法还有 notifyAll，用于唤醒再监视器上等待的所有线程。

#### 后台守护线程：setDaemon方法

守护线程的优先级较低，用于为系统中的其他对象和线程提供服务。将一个用户线程设置为守护线程的方法是在线程对象创建之前用线程对象的 setDaemon（true）来设置。

后台守护线程是 JVM 级别的，，比如**垃圾回收线程就是一个经典的守护线程**，在我们的程序中不再有任何线程运行时，程序就不会产生垃圾，垃圾回收器也就无事可做，所以在回收 JVM 上仅剩的线程时，垃圾回收线程会自动离开。它始终在低级别的状态下运行，用于实时监控和管理系统中的可回收资源。

**守护线程是运行在后台的一种特殊线程，其独立于控制终端并且周期性地执行某种任务或等待处理某些已发生的时间。**也就是说，守护线程不依赖于终端，但是依赖于 JVM，于 JVM “同生共死”。**在 JVM 中所有的线程都是守护线程是，JVM 就可以退出了，如果还有一个或一个以上的非守护线程，则 JVM 不会退出。**



#### sleep 方法和 wait 方法的区别

- [ ] sleep 方法属于 Thread 类，wait 方法则属于 Object 类。
- [ ] sleep 方法暂停执行指定的时间，让出 CPU 给其他线程，但其监控状态依然保持，在指定的时间过后又会自动恢复运行状态。
- [ ] 在调用 sleep 方法时，线程不会释放对象锁。
- [ ] 在调用 wait 方法时，线程会放弃对象锁，进入等待锁池，只有针对此对象调用 notify 方法后，该线程才能进入对象锁池准备获取对象锁，并进入运行状态。



#### start 方法和 run 方法的区别

- [ ] start 方法用于启动线程，真正实现了多线程运行。在调用了线程的 start 方法后，线程会在后台执行，无须等待 run 方法体的代码执行完毕，就可以继续执行下面的代码。
- [ ] 在通过调用 Thread 类的 start 方法启动一个线程时，此线程处于就绪状态，并没有运行。
- [ ] run 方法也叫线程体，包含了要执行的线程的逻辑代码，在调用 run 方法后，线程会进入运行状态，开始运行 run 方法中的代码。在 run 方法运行结束后，该线程终止，CPU 再次调度其他线程。



#### 终止线程的4种方式

**1、正常执行结束**

指线程体执行完成，线程自动结束。

**2、使用退出标志退出线程**

在一般情况下，在 run 方法执行完毕时，线程会正常结束。然而，有些线程时后台线程，需要长时间运行，只有在系统满足某些特殊条件后，才能退出这些线程。这时可以使用一个变量来控制循环，比如设置一个 boolean 类型的标志，并通过设置这个标志为 true 或 false 来控制 while 循环是否退出，具体的实现代码如下：

```java
	public class ThreadSafe extends Thread {
        public volatile boolean exit = false;
        public void run(){
            while(!exit){
                //执行业务逻辑代码
            }
        }
    }
```

**3、使用Interrupt方法终止线程**

使用 Interrupt 方法终止线程有如下两种情况。

（1）线程处于阻塞状态。例如，在使用 sleep，调用锁的 wait 或者调用 socket 的receiver、accept 等方法时，会使线程处于阻塞状态。在调用线程的 interrupt 方法时，会抛出 InterruptedException 异常。我们通过在代码种铺货该异常，然后通过 break 跳出状态检测循环，结束这个线程的执行。

```java
	public class ThreadSafe extends Thread {
        public void run(){
            while(!isInterrupted()){
               	try{
                    Thread.sleep(5000);
                }catch(InterruptedException e){
                    e.printStackTrace();
                    break;
                }
            }
        }
    }
```

（2）线程未处于阻塞状态。此时，使用 isInterruped 方法判断线程的中断标志位来退出循环。在调用 interrupt 的时，中断标志位会被设置为 true，此时并不能立刻退出线程，而是需要执行线程终止前的资源释放操作，在等待资源释放完毕后方可安全退出该线程。

**4、使用stop方法终止线程：不安全**

在程序中可以直接调用 Thread.stop 方法强行终止线程，但可能会产生不可预料的后果。

在程序使用 Thread.stop 方法终止线程时，该线程的子线程会抛出 ThreadDeathError 错误，并且释放子线程持有的所有锁。加锁的代码块一般被用于保护数据的一致性，**如果在调用 Thread.stop 方法后导致该线程所持有的所有锁突然释放而使锁资源不可控制，被保护的数据就可能出现不一致的情况，其他线程在使用这些被破坏的数据时，有可能使程序运行错误**。因此，并不推荐采用这种方法终止线程。



## 线程上下文切换

CPU 利用时间片轮询来为每个任务都服务一定的时间，然后把当前任务的状态保存下来，继续服务下一个任务。**任务的状态保存及再加载的过程叫做线程的上下文切换**。



#### 线程上下文切换的流程

线程上下文切换指的是内核（操作系统的核心）在 CPU 上对进程或者线程进行切换。上下文切换过程中的信息被保存在**进程控制块**（PCB-Process Control Block）中。PCB 又被称作切换帧（SwitchFrame）。线程上下文切换的信息会一直被保存在 CPU 的内存中，直到被再次使用。线程上下文切换的流程如下。

1. **挂起一个线程，将这个线程在 CPU 的状态（上下文信息）存储与内存的 PCB 中。**
2. **在 PCB 中检索下一个线程的上下文并将其在 CPU 的寄存器中恢复。**
3. **跳转到程序计数器所指向的位置（即跳转到线程被中断时的代码行）并恢复该线程。**



#### 导致线程上下文切换的原因

- 当前正在执行的任务完成，系统的 CPU 正常调度下一个任务。
- 当前正在执行的任务遇到 I/O 等阻塞操作，调度器挂起此任务，继续调度下一个任务。
- 多个任务并发抢占锁资源，当前任务没有抢到锁资源，被调度器挂起，继续调度下一个任务。
- 用户的代码挂起当前任务，比如线程执行 sleep 方法，让出 CPU
- 硬件中断







# Java线程池

## Java线程池的原理

Java 中的线程池是**通过 Executor 框架实现的**，在该框架中用到了 Executor、Executors、ExecutorService、ThreadPoolExecutor、Callable、Future、FutureTask 这几个核心类。

### 一 、[Executor、ExecutorService 和 Executors 继承关系](https://blog.csdn.net/qq_45537574/article/details/112003683)和[UML类图](https://so.csdn.net/so/search?q=UML类图&spm=1001.2101.3001.7020)

`Executor`, `ExecutorService`, `Executors` 这三者均是 Java Executor 框架的类，用来提供线程池的功能。

因为创建和管理线程非常销耗资源，并且操作系统通常对线程数有限制，所以建议使用线程池来并发执行任务，而不是每次请求进来时创建一个线程。

使用线程池不仅可以提高应用的响应时间，还可以避免 `java.lang.OutOfMemoryError: unable to create new native thread` 之类的错误。

在 Java 1.5 及之前，开发者需要关心线程池的创建和管理，但在 Java 1.5 之后， `Executor` 框架提供了多种内置的线程池，例如：`FixedThreadPool` ( 包含固定数目的线程 ) 、`CachedThreadPool` ( 可根据需要创建新的线程 ) 等等。

![在这里插入图片描述](assets/JUC.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9qaW4yMWNlbg==,size_16,color_FFFFFF,t_70.png)

#### 1.1、三者的继承关系

```java
一、线程池的体系结构：
    Executor 负责线程的使用和调度的 根接口
	|--ExecutorService  接口： 线程池的主要接口。增加了返回Future 对象
		|--ThreadPoolExecutor 线程池的实现类
		|--ScheduledExceutorService 接口： 负责线程的调度
			|--ScheduledThreadPoolExecutor ： 继承ThreadPoolExecutor，实现了ScheduledExecutorService
```

### 二、工具类 ： Executors

```java
ExecutorService pool = Executors.newFixedThreadPool() ： 创建固定大小的线程池
ExecutorService pool = Executors.newCachedThreadPool() ： 缓存线程池，线程池的数量不固定，可以根据需求自动的更改数量。
ExecutorService pool = Executors.newSingleThreadExecutor() ：创建单个线程池。 线程池中只有一个线程

ScheduledExecutorService pool = Executors.newScheduledThreadPool() ： 创建固定大小的线程，可以延迟或定时的执行任务
```

三者最主要的区别是 Executor 是一个抽象层面的 **根接口**

```java
public interface Executor {
    void execute(Runnable command);
}
```

**Executor 与 Thread 的不同：**

不同于 `Thread` 类将任务和执行耦合在一起， `Executor` 将 **任务本身和执行任务分离** 。
可以阅读 `difference between Thread and Executor` 来了解 Thread 和 Executor 间更多的不同。

### 三、ExecutorService： 接口

ExecutorService 接口， 对 Executor 接口进行了扩展，提供了返回 Future 对象，终止，关闭线程池等方法。

当调用 `shutdown()`时，线程池会停止接受新的任务，但会完成正在 pending 中的任务。

ExecutorService 部分代码如下：

```java
public interface ExecutorService extends Executor {
    void shutdown();
    <T> Future<T> submit(Callable<T> task);
    <T> Future<T> submit(Runnable task, T result);
    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks,
							 long timeout, TimeUnit unit) throws InterruptedException;
123456
```

#### 3.1、`Future` 接口

`Future` 提供了异步执行，无需等待任务执行的完成，只要提交需要执行的任务，然后在需要时检查 `Future` 是否已经有了结果，如果任务已经执行完成，就可以通过 `Future.get()` 方法获得执行结果。

**Future 的方法：**

| 返回值    | 方法名                                  | 说明                                        |
| --------- | --------------------------------------- | ------------------------------------------- |
| `boolean` | `cancel(boolean mayInterruptIfRunning)` | 试图取消执行这一任务。                      |
| `V`       | `get()`                                 | 如果有必要等待计算完成,然后获取它的结果。   |
| `boolean` | `isCancelled()`                         | 返回 `true`如果这个任务被取消之前完成正常。 |
| `boolean` | `isDone()`                              | 返回 `true`如果这个任务完成。               |

需要注意的是，`Future.get()` 方法是一个阻塞式的方法，如果调用时任务还没有完成，会等待直到任务执行结束。

通过 `ExecutorService.submit()` 方法返回的 `Future` 对象，还可以取消任务的执行。
`Future` 提供了 `cancel()` 方法用来取消执行 `pending` 中的任务。

### 四、Executors 是一个工具类

`Executors` 类似于 `Collections` 、`Arrays` 等 ，是一个工具类，提供工厂方法来创建不同类型的线程池。

`Executors` 创建线程池的方法：

```java
// 创建固定大小的线程池
ExecutorService  pool = Executors.newFixedThreadPool() ;

// 缓存线程池，线程池的数量不固定，可以根据需求自动的更改数量
ExecutorService  pool = Executors.newCachedThreadPool();

// 创建单个线程池。 线程池中只有一个线程
ExecutorService  pool = Executors.newSingleThreadExecutor() ;
		
// 创建固定大小的线程，可以延迟或定时的执行任务
ScheduledExecutorService  pool = Executors.newScheduledThreadPool();
1234567891011
```

### 五、 三者的区别

#### 5.1、Executor 和 ExecutorService 的区别：

1. `Executor` 是 负责线程的使用和调度的 根接口 ； `ExecutorService` 接口继承了 `Executor`，也是接口。
2. `Executor` 接口定义了 `execute()` 方法用来接收一个 `Runnable` 接口的对象，而 `ExecutorService` 接口中的 `submit()` 方法可以接受 `Runnable` 和 `Callable` 接口的对象。
3. `Executor` 中的 `execute()` 方法不返回任何结果，而 `ExecutorService` 中的 `submit()`方法可以通过一个 `Future` 对象返回运算结果。
4. 除了允许客户端提交任务，`ExecutorService` 还提供用来控制线程池的方法。比如：调用 `shutDown()` 方法终止线程池。可以通过 《Java Concurrency in Practice》 一书了解更多关于关闭线程池和如何处理 pending 的任务的知识。

#### 5.2、总结

下表列出了 `Executor` 和 `ExecutorService` 的区别：

| Executor                                                  | ExecutorService                                              |
| --------------------------------------------------------- | ------------------------------------------------------------ |
| Executor 是 java 线程池的核心接口，用来并发执行提交的任务 | ExecutorService 继随 Executor，也是接口，扩展了方法，提供了异步执行和关闭线程池的方法 |
| 只有 `execute(Runnable command)` 提交任务                 | 增加了 `submit(Callable<T> task)` 、 `submit(Runnable task, T result)`方法提交任务 |
| `execute()` 方法 无返回值                                 | 两个 `submit()` 返回 Future 对象，可用来获取任务执行结果     |
| 不能取消任务                                              | 可以通过 `Future.cancel()` 取消 pending 中的任务             |
| 没有提供和关闭线程有关的方法                              | 提供的关闭线程的 `shutdown()` 方法                           |

#### 5.3、Executors 与 前面二者 的区别：

`Executors` 类提供工厂方法用来创建不同类型的线程池。比如:：

- `newSingleThreadExecutor()` 创建一个只有一个线程的线程池，
- `newFixedThreadPool(int numOfThreads)` 来创建固定线程数的线程池，
- `newCachedThreadPool()` 可以根据需要创建新的线程，但如果已有线程是空闲的会重用已有线程。

#### 5.4、ThreadPoolExecutor 的推荐

当ExecutorService 线程池中的线程均处于工作状态，并且线程数已达线程池允许的最大线程数时，就会采取指定的饱和策略来处理新提交的任务。

总共有四种策略：

1. `AbortPolicy` （终止执行）：**默认策略**。
   Executor会抛出一个RejectedExecutionException运行异常到调用者线程来完成终止。
2. `CallerRunsPolicy`（调用者线程来运行任务）：
   这种策略会由调用execute方法的线程自身来执行任务，它提供了一个简单的反馈机制并能降低新任务的提交频率。
3. `DiscardPolicy` （丢弃策略）：不处理，直接丢弃提交的任务。
4. `DiscardOldestPolicy` （丢弃队列里最近的一个任务）：

如果 `Executor` 还未 `shutdown()` 的话，则丢弃工作队列的最近的一个任务，然后执行当前任务。

如果使用 `Executors` 的工厂方法创建的线程池，那么饱和策略都是采用默认的 `AbortPolicy` ，所以如果我们想当线程池已满时，使用调用者的线程来运行任务，就要自己创建线程池，指定想要的饱和策略，而不是使用 `Executors` 。

所以我们可以根据需要创建 `ThreadPoolExecutor` ( ExecutorService 接口的实现类 ) 对象，自定义一些参数，而不是调用 `Executors` 的工厂方法创建。

当然，在使用 Spring 框架的项目中，也可以使用 Spring 提供的 `ThreadPoolTaskExecutor` 类来创建线程池。`ThreadPoolTaskExecutor` 与 `ThreadPoolExecutor` 类似，也提供了许多参数用来自定义线程池，比如：核心线程池大小，线程池最大数量，饱和策略，线程活动保持时间等等。





## ThreadPoolExecutor

![image-20221111210121567](assets/JUC.assets/image-20221111210121567.png)

其中，**ThreadPoolExecutor 是构建线程的核心方法**，该方法的定义如下：

```java
	public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue) {
        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
             Executors.defaultThreadFactory(), defaultHandler);
    }
```

ThreadPoolExecutor 构造函数的具体参数如表所示：

| 序号 | 参数            | 说明                                                         |
| ---- | --------------- | ------------------------------------------------------------ |
| 1    | corePoolSize    | 线程池中核心线程的数量                                       |
| 2    | maximumPoolSize | 线程池中最大线程的数量                                       |
| 3    | keepAliveTime   | 当前线程数量超过 corePoolSize 时，空闲线程的存活时间         |
| 4    | unit            | keepAliveTime的时间单位                                      |
| 5    | workQueue       | 任务队列，被提交但尚未执行的任务存放的地方                   |
| 6    | threadFactory   | 线程工厂，用于创建线程，可使用默认的线程工厂或自定义线程工厂 |
| 7    | handler         | 由于任务过多或其他原因导致线程池无法处理时的任务拒绝策略     |



## Java线程池的工作流程

Java线程池的工作流程：线程池刚被创建时，只是向系统申请一个用于执行线程队列和管理线程池的线程资源。在调用execute（）添加一个任务时，线程池会按照如下流程执行任务。

- [ ] 如果正在运行的线程数量少于 corePoolSize （用户定义的核心线程数），线程池就会立即创建线程并执行该线程任务。
- [ ] 如果正在运行的线程数量大于或等于 corePoolSize，该任务就将被放入阻塞队列中。
- [ ] 在阻塞队列已满且正在运行的线程数量少于 maximunPoolSize 时，线程池会创建非核心线程立刻执行该线程任务。
- [ ] 在阻塞队列已满且正在运行的线程数量大于或等于 maximumPoolSize 时，线程池执行拒绝策略，默认会抛出RejectedExecutionException异常
- [ ] 在线程任务执行完毕后，该任务将从线程池队列中移除，线程池从队列中去下一个线程任务继续执行。
- [ ] 在线程处于空闲状态的时间超过 keepAliveTime 时间时，正在运行时的线程数量超过corePoolSize，该线程将会被认定为空闲线程并停止。因此在线程池中的所有线程任务都执行完毕后，线程池会收缩到corePoolSize大小

![img](assets/JUC.assets/b58f8c5494eef01fa8e8f11f17b5a92cbe317dc5.png)



## 线程池的拒绝策略

如果线程池中的核心线程被用完且阻塞队列已排满，则此时线程池的线程资源已耗尽，线程池将没有足够的线程资源执行新的任务。为了保证操作系统的安全，线程池将通过拒绝策略处理新添加的线程任务。JDK内置的拒绝策略有 AbortPolicy、CallerRunsPolicy、DiscardOldestPolicy、DiscardPolicy 这 4 种，默认的拒绝策略在 ThreadPoolExecutor 中作为内部类提供。在默认的拒绝策略不满足应用的需求时，可以自定义拒绝策略。

```java
   /**
     * The default rejected execution handler	默认使用 AbortPolicy 策略
    */
	private static final RejectedExecutionHandler defaultHandler = new AbortPolicy();
```



#### 1、AbortPolicy

AbortPolicy 直接抛出异常，阻止线程正常执行，具体的 JDK 实现源码如下：

```java
	public static class AbortPolicy implements RejectedExecutionHandler{
        public AbortPolicy() { }
        public void rejectedExecution(Runnable r,ThreadPoolExecutor e){
            //直接抛出异常信息，不做任何处理
            throw new RejectedExecutionException("Task " + r.toString + 
                                                "rejected from " + e.toString());
        }
    }
```

#### 2、CallerRunsPolicy

CallerRunsPolicy 的拒绝策略：如果被丢弃的线程任务未关闭，则执行该线程任务。注意，CallerRunsPolicy 的拒绝策略不会真的丢弃任务。具体的 JDK 实现源码如下：

```java
	public static class CallerRunsPolicy implements RejectedExecutionHandler {
        public CallerRunsPolicy() { }
        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
            if (!e.isShutdown()) {
                r.run();	// 执行被丢弃的任务
            }
        }
    }
```

#### 3、DiscardOldestPolicy

DiscardOldestPolicy 的拒绝策略：移除线程队列中最早的一个线程任务，并尝试提交当前任务。具体的 JDK 实现源码如下：

```java
	public static class DiscardOldestPolicy implements RejectedExecutionHandler {
        public DiscardOldestPolicy() { }
        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
            if (!e.isShutdown()) {
                e.getQueue().poll();
                e.execute(r);
            }
        }
    }
```

#### 4、DiscardPolicy

DiscardPolicy 的拒绝策略：丢弃当前的线程任务而不做任何处理。如果系统允许在资源不足的情况下丢弃部分任务，则这将是保证系统安全、稳定的一种很好的方案。具体的 JDK 实现源码如下：

```java
	public static class DiscardPolicy implements RejectedExecutionHandler {
        public DiscardPolicy() { }
        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
        }
    }
```

#### 5、自定义拒绝策略

以上4种拒绝策略均实现了 RejectedExecutionHandler 接口，如果无法满足实际需求，则用户可以扩展 RejectedExecutionHandler 接口来实现拒绝策略，并捕获异常来实现自定义拒绝策略。

```java
	public class DiscardOldestNPolicy implements RejectedExecutionHandler {
        private int discardNumber = 3;
        private List<Runnable> discardList = new ArrayList<>();
        public DiscardOldestNPolicy(int discardNumber){
            this.discardNumber = discardNumber;
        }
        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
            if(e.getQueue().size() > discardNumber){
                //1:批量移除队列中的discardNumber个任务
                e.getQueue().drainTo(discardList,discardNumber);
                discardList.clear();//2:清空discardList 列表
                if(!e.isShutDown()){
                    e.execute(r);//3:尝试提交当前任务
                }
            }
        }
    }
```





## 5种常用的线程池

Java 定义了 Executor 接口，并在接口中定义了 execute（）用于执行一个线程任务。然后通过 ExecutorService 实现 Executor 接口并执行具体的线程操作。ExecutorService 接口有多个实现类可用于创建不同的线程池。

```java
	//创建方式:
	ExecutorService XXXThreadPool = Executors.newXXXThreadPool(XXX);
```

#### 1.**newCachedThreadPool**

用于创建一个缓存线程池。没有核心线程,直接向 SynchronousQueue 中提交任务，如果有空闲线程，就去取出任务执行。如果没有空闲线程，就新建一个。执行完任务的线 程有 60 秒生存时间，如果在这个时间内可以接到新任务，才可以存活下去。

```java
	public static ExecutorService newCachedThreadPool() { 
    	return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new 
                                  SynchronousQueue<Runnable>()); 
	} 
```

#### 2.**newFixedThreadPool**

用于创建一个固定线程数量的线程池。最大线程和核心线程一致，用的是LinkedBlockingQueue，无限容量。

```java
	public static ExecutorService newFixedThreadPool(int nThreads) { 
     	return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new
                                   LinkedBlockingQueue<Runnable>()); 
	} 
```

#### 3.**newScheduledThreadPool**

用于创建一个可定时调度的线程池，可设置在指定的延迟时间后执行或者定时执行某个线程任务。核心线程和最大线程都有，采用DelayedWorkQueue 队列。

```java
	public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {
    	return new ScheduledThreadPoolExecutor(corePoolSize);
	}
	public ScheduledThreadPoolExecutor(int corePoolSize) {
    	super(corePoolSize, Integer.MAX_VALUE, DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS, 										new DelayedWorkQueue());  
	}
	private static final long DEFAULT_KEEPALIVE_MILLIS = 10L;  
```

下面是具体的使用方式：

```java
	ScheduledExecutorService scheduledExecutorService = 
        				Executors.newScheduledThreadPool(3);
	//1、创建一个延迟 3s 执行的线程
	scheduledExecutorService.schedule(new Runnable(){
        @Override
        public void run(){
            System.out.println("delay 3 seconds execute.");
        }
    },3,TimeUnit.SECONDS);
    //2、创建一个延迟 1s 执行其每 3s 执行一次的线程
	scheduledExecutorService.scheduleAtFixedRate(new Runnable(){
        @Override
        public void run(){
            System.out.println("delay 1 seconds execute,repeat execute every 3 seconds");
        }
    },1,3,TimeUnit.SECONDS);
```

#### 4.**newSingleThreadExecutor**

用于保证在线程池中有且只有一个可用的线程，在该线程停止或发送异常时，newSingleThreadExecutor 会启动一个新的线程来代替该线程继续执行任务；最大线程和核心线程一致，用的是LinkedBlockingQueue，无限容量。

```java
	public static ExecutorService newSingleThreadExecutor() { 
     	return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, 								TimeUnit.MILLISECONDS,new LinkedBlockingQueue<Runnable>())); 
	}  
```

#### 5.**newWorkStealingPool**

用于创建持有足够线程的线程池来达到快速运算的目的，在内部通过多个队列来减少各个线程调度产生的竞争。这里所说的有足够的线程，指 JDK根据当前线程的运行需求向操作系统申请足够的线程，以保障线程的快速执行，并最大限度地使用系统资源，提高并发计算地效率，省去用户根据 CPU 资源估算并行度地过程。当然，如果开发者想自己定义线程地并发数，则也可以将其作为i参数传入。



## Tomcat 线程池

Tomcat 线程池扩展了 ThreadPoolExecutor，行为稍有不同

- 当前线程数小于corePoolSize，则去创建工作线程；
- 当前线程数大于corePoolSize，但小于maximumPoolSize，则去创建工作线程；
- 如果总线程数达到 maximumPoolSize
  - 这时不会立刻抛 RejectedExecutionException 异常
  - 而是再次尝试将任务放入队列，如果还失败，才抛出 RejectedExecutionException 异常



## 自定义线程池

##### 步骤1：自定义拒绝策略接口

```java
@FunctionalInterface // 拒绝策略
interface RejectPolicy<T> {
 void reject(BlockingQueue<T> queue, T task);
}
```

##### 步骤2：自定义任务队列

```java
class BlockingQueue<T> {
    // 1. 任务队列
	private Deque<T> queue = new ArrayDeque<>();
    // 2. 锁
    private ReentrantLock lock = new ReentrantLock();
    // 3. 生产者条件变量
    private Condition fullWaitSet = lock.newCondition();
    // 4. 消费者条件变量
    private Condition emptyWaitSet = lock.newCondition();
    // 5. 容量
    private int capcity;
    public BlockingQueue(int capcity) {
    	this.capcity = capcity;
    }
    
     // 阻塞获取
    public T take() {
    	lock.lock();
     	try {
     		while (queue.isEmpty()) {
     			try {
     				emptyWaitSet.await();
     			} catch (InterruptedException e) {
     				e.printStackTrace();
     			}
    	 	}
     		T t = queue.removeFirst();
     		fullWaitSet.signal();
     		return t;
     	} finally {
     		lock.unlock();
     	}
     }
    
    // 阻塞添加
 	public void put(T task) {
 		lock.lock();
 		try {
 			while (queue.size() == capcity) {
 				try {
 					log.debug("等待加入任务队列 {} ...", task);
 					fullWaitSet.await();
 				} catch (InterruptedException e) {
 					e.printStackTrace();
 				}
 			}
 			log.debug("加入任务队列 {}", task);
 			queue.addLast(task);
 			emptyWaitSet.signal();
 		} finally {
 			lock.unlock();
 		}
 	}
    
    public int size() {
 		lock.lock();
 		try {
 			return queue.size();
 		} finally {
 			lock.unlock();
 		}
 	}
    
    // 策略模式添加
  	public void tryPut(RejectPolicy<T> rejectPolicy, T task) {
    	lock.lock();
    	try {
      		// 判断队列是否为满
      		if (queue.size() == capcity) {
        		rejectPolicy.reject(this, task);
      		} else { // 有空闲
        		queue.addLast(task);
        		emptyWaitSet.signal();
      		}
    	} finally {
      		lock.unlock();
    	}
  	}
```

带超时阻塞的获取和添加

```java
	public T poll(long timeout, TimeUnit unit) {
 		lock.lock();
 		try {
 			// 将 timeout 统一转换为 纳秒
 			long nanos = unit.toNanos(timeout);
 			while (queue.isEmpty()) {
 				try {
 					// 返回值是剩余时间
 					if (nanos <= 0)
 						return null;
 					nanos = emptyWaitSet.awaitNanos(nanos);
 				} catch (InterruptedException e) {
 					e.printStackTrace();
 				}
 			}
 			T t = queue.removeFirst();
 			fullWaitSet.signal();
 			return t;
 		} finally {
 			lock.unlock();
 		}
    }

	// 带超时时间阻塞添加
	public boolean offer(T task, long timeout, TimeUnit timeUnit) {
 		lock.lock();
 		try {
 			long nanos = timeUnit.toNanos(timeout);
 			while (queue.size() == capcity) {
 				try {
 					if(nanos <= 0) {
 						return false;
 					}
 					log.debug("等待加入任务队列 {} ...", task);
 					nanos = fullWaitSet.awaitNanos(nanos);
     			} catch (InterruptedException e) {
 					e.printStackTrace();
 				}
 			}
 			log.debug("加入任务队列 {}", task);
 			queue.addLast(task);
 			emptyWaitSet.signal();
 			return true;
 		} finally {
 			lock.unlock();
 		}
 	}
```

##### 步骤3：自定义线程池

```java
class ThreadPool {
 	// 任务队列
	private BlockingQueue<Runnable> taskQueue;
 	// 线程集合
 	private HashSet<Worker> workers = new HashSet<>();
 	// 核心线程数
 	private int coreSize;
 	// 获取任务时的超时时间
    private long timeout;
 	private TimeUnit timeUnit;
 	private RejectPolicy<Runnable> rejectPolicy;
 	// 执行任务
 	public void execute(Runnable task) {
 		// 当任务数没有超过 coreSize 时，直接交给 worker 对象执行
 		// 如果任务数超过 coreSize 时，加入任务队列暂存
 		synchronized (workers) {
 			if(workers.size() < coreSize) {
 				Worker worker = new Worker(task);
 				log.debug("新增 worker{}, {}", worker, task);
 				workers.add(worker);
 				worker.start();
 			} else {
                 // taskQueue.put(task);
                 // 1) 死等
                 // 2) 带超时等待
                 // 3) 让调用者放弃任务执行
                 // 4) 让调用者抛出异常
                 // 5) 让调用者自己执行任务
 				taskQueue.tryPut(rejectPolicy, task);
    		}
 		}
 	}
 	public ThreadPool(int coreSize, long timeout, TimeUnit timeUnit, int queueCapcity,
                      RejectPolicy<Runnable> rejectPolicy) {
 		this.coreSize = coreSize;
 		this.timeout = timeout;
 		this.timeUnit = timeUnit;
 		this.taskQueue = new BlockingQueue<>(queueCapcity);
 		this.rejectPolicy = rejectPolicy;
 	}
 	class Worker extends Thread{
 		private Runnable task;
 		public Worker(Runnable task) {
 			this.task = task;
 		}
 		@Override
 		public void run() {
 			// 执行任务
 			// 1) 当 task 不为空，执行任务
 			// 2) 当 task 执行完毕，再接着从任务队列获取任务并执行
			// while(task != null || (task = taskQueue.take()) != null) {
 			while(task != null || (task = taskQueue.poll(timeout, timeUnit)) != null) {
 				try {
 					log.debug("正在执行...{}", task);
     				task.run();
 				} catch (Exception e) {
 					e.printStackTrace();
 				} finally {
 					task = null;
 				}
 			}
 			synchronized (workers) {
 				log.debug("worker 被移除{}", this);
 				workers.remove(this);
 			}
 		}
 	}
}
```

##### 步骤4：测试

```java
public static void main(String[] args) {
	ThreadPool threadPool = new ThreadPool(1,
                            1000, TimeUnit.MILLISECONDS, 1, (queue, task)->{
                 // 1. 死等
                // queue.put(task);
                 // 2) 带超时等待
                // queue.offer(task, 1500, TimeUnit.MILLISECONDS);
                 // 3) 让调用者放弃任务执行
                // log.debug("放弃{}", task);
                 // 4) 让调用者抛出异常
                // throw new RuntimeException("任务执行失败 " + task);
                 // 5) 让调用者自己执行任务
 					task.run();
 	});
 	for (int i = 0; i < 4; i++) {
 		int j = i;
 		threadPool.execute(() -> {
            try {
                Thread.sleep(1000L);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            log.debug("{}", j);
     	});
	}
}
```





# Java的锁

​		**Java的锁主要用于保障线程在多并发情况下数据的一致性。**在多线程编程中为了保证数据的一致性，我们通常需要在使用对象或者调用方法之前加锁，这时如果有其他线程也需要该对象或者调用该方法，则首先要获取锁，如果某个线程发现锁正在被其他线程使用，就会进入阻塞队列等待锁的释放，直到其他线程执行完毕并释放锁，该线程才有机会再次获取锁并执行操作。这样就保障了在同一时刻只有一个线程持有该对象的锁并修改该对象，从而保证数据的安全。

​		锁从乐观和悲观的角度可分为乐观锁和悲观锁，从获取资源的公平性角度可分为公平锁和非公平锁，从是否共享资源的角度可分为共享锁和独占锁，从锁的状态的角度可分为偏向锁、轻量级锁和重量级锁。同时，在 JVM 中还巧妙设计了自旋锁以更快地使用 CPU 资源。



## 乐观锁

乐观锁采用乐观地思想处理数据，在每次读取数据时都认为别人不会修改该数据，所有不会加锁。乐观锁在更新数据的时候，会采用尝试更新，不断重试的方式更新数据。乐观的认为，不加锁的并发操作是没有事情的。

Java 中的乐观锁大部分是通过 CAS（Compare And Swap，比较和交换）操作实现的，CAS 是一种原子更新操作，在对数据操作之前首先会比较当前值跟传入的值是否一样，如果一样则更新，否则不执行更新操作，直接返回失败状态。

```java
	while (true) {
 		int prev = balance.get();
 		int next = prev - amount;
 		if (balance.compareAndSet(prev, next)) {
 			break;
 		}
 	}
```

## 悲观锁

悲观锁采用悲观的思想处理数据，在每次读取数据时都认为别人会修改数据，所以每次在读写数据时都会加锁，这样在别人想读写这个数据时就会阻塞、等待直到获取锁。

Java 中的悲观锁大部分基于 AQS（Abstract Queued Synchronized，抽象的队列同步器）架构实现。AQS 定义了一套多线程访问共享资源的同步框架，许多同步类的实现都依赖于它，例如常用的 Synchronized、ReentrantLock、Semaphore、CountDownLatch 等。该框架下的锁会先尝试以 CAS 乐观锁去获取锁，如果获取不到，则会转为悲观锁（如：ReentrantLock）







## synchronized

**synchronized关键字解决的是多个线程之间访问资源的同步性，调用操作系统内核态做同步，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。**



**如何简洁地回答`synchroized`的底层原理这个问题。**

每个 Java 对象都可以关联一个 Monitor 对象，加锁就是在竞争 monitor 对象。Java虚拟机是通过进入和退出Monitor对象来实现代码块同步和方法同步的，对代码块加锁是通过在前后分别加上 monitorenter 和 monitorexit 指令实现的，对方法是否加锁是通过一个标志位 ACC_SYNCHRONIZED 来判断的。



#### **synchronized的三大特性**

面试时经常拿`synchronized`关键字和`volatile`关键字的特性进行对比，**`synchronized`关键字可以保证并发编程的三大特性：原子性、可见性、有序性，而`volatile`关键字只能保证可见性和有序性，不能保证原子性，也称为是轻量级的`synchronized`**。



#### **synchronized的作用范围**

**修饰实例方法:** 作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁

**修饰静态方法:** 也就是给当前类加锁，会作用于类的所有对象实例。因为访问静态synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。

**修饰代码块:** 指定加锁对象，对给定对象加锁，进入同步代码块前要获得给定对象的锁。



#### **synchronized的底层原理**

##### 对象头

在HotSpot虚拟机中，Java对象在内存中的布局大致可以分为三部分：**对象头**、**实例数据**和**填充对齐**。

![img](assets/JUC.assets/20222795951398.png)

因为`synchronized`用的锁是存在对象头里的，这里我们需要重点了解对象头。如果对象头是数组类型，则对象头由**Mark Word**、**Class MetadataAddress**和**Array length**组成。如果对象头非数组类型，对象头则由**Mark Word**和**Class MetadataAddress**组成。在32位虚拟机中，数组类型的Java对象头的组成如下表，64位虚拟机的 Mark Word 为 64 bit：

![img](assets/JUC.assets/v2-05078c2d4a4218fcd71738a819536d17_720w.webp)



##### **重量级锁的底部实现原理：Monitor**

在jdk1.6之前，`synchronized`只能实现重量级锁，Java虚拟机是基于Monitor对象来实现重量级锁的，所以首先来了解下Monitor，在Hotspot虚拟机中，Monitor是由ObjectMonitor实现的，其源码是用C++语言编写的，首先我们先下载Hotspot的源码，源码下载链接：[http://hg.openjdk.java.net/jdk8/jdk8/hotspot](https://link.zhihu.com/?target=http%3A//hg.openjdk.java.net/jdk8/jdk8/hotspot)，找到ObjectMonitor.hpp文件，路径是`src/share/vm/runtime/objectMonitor.hpp`，这里只是简单介绍下其数据结构

```cpp
ObjectMonitor() {
    _header       = NULL;
    _count        = 0; //锁的计数器，获取锁时count数值加1，释放锁时count值减1，直到
    _waiters      = 0, //等待线程数
    _recursions   = 0; //锁的重入次数
    _object       = NULL; 
    _owner        = NULL; //指向持有ObjectMonitor对象的线程地址
    _WaitSet      = NULL; //处于wait状态的线程，会被加入到_WaitSet
    _WaitSetLock  = 0 ;
    _Responsible  = NULL ;
    _succ         = NULL ;
    _cxq          = NULL ; //阻塞在EntryList上的单向线程列表
    FreeNext      = NULL ;
    _EntryList    = NULL ; //处于等待锁block状态的线程，会被加入到该列表
    _SpinFreq     = 0 ;
    _SpinClock    = 0 ;
    OwnerIsThread = 0 ;
  }
```



其中 _owner、_WaitSet和_EntryList 字段比较重要，它们之间的转换关系如下图

![img](assets/JUC.assets/v2-c447699ef3e74bd7855c5710cd7308d2_720w.webp)

从上图可以总结获取Monitor和释放Monitor的流程如下：

1. **当多个线程同时访问同步代码块时，首先通过CAS的方式尝试将Monitor中的owner字段设置为当前线程**，同时count加1，若发现之前的owner的值就是指向当前线程的，recursions也需要加1。**如果CAS尝试获取锁失败，则进入到 EntryList 中，进行阻塞状态**。
2. **当获取锁的线程调用`wait()`方法，则会将owner设置为null**，同时count减1，recursions减1，**当前线程加入到WaitSet中，直到某个时刻被 notify 方法 或者 notifyAll 方法唤醒，会再次进入 EntryList 中。**
3. **当前线程执行完同步代码块时，则会释放锁， 唤醒 EntryList**，count减1，recursions减1。当recursions的值为0时，说明线程已经释放了锁。





#### **JDK1.6为什么要对synchronized进行优化？**

因为Java虚拟机是通过进入和退出Monitor对象来实现代码块同步和方法同步的，而**Monitor是依靠底层操作系统的`Mutex Lock`来实现的**，操作系统实现线程之间的切换**需要从用户态转换到内核态，这个切换成本比较高，对性能影响较大**。





#### **JDK1.6对synchronized做了哪些优化？**

##### **锁的升级**

在JDK1.6中，为了减少获得锁和释放锁带来的性能消耗，引入了偏向锁和轻量级锁，锁的状态变成了四种，如下图所示。锁的状态会随着竞争激烈逐渐升级，但通常情况下，锁的状态只能升级不能降级。这种**只能升级不能降级的策略是为了提高获得锁和释放锁的效率**。

![img](assets/JUC.assets/v2-b5939bac6678bd240315edf45c2609b3_720w.webp)

64 位虚拟机 Mark Word 的 锁状态 

![image-20221113101903787](assets/JUC.assets/image-20221113101903787.png)

##### 偏向锁

引入偏向锁的目的：减少只有一个线程执行同步代码块时的性能消耗，即在没有其他线程竞争的情况下，一个线程获得了锁。

偏向锁的获取流程：

1. 检查对象头中Mark Word是否为可偏向状态，如果不是则直接升级为轻量级锁。
2. 如果是，判断Mark Work中的线程ID是否指向当前线程，如果是，则执行同步代码块。
3. 如果不是，则进行CAS操作竞争锁，如果竞争到锁，则将Mark Work中的线程ID设为当前线程ID，执行同步代码块。
4. 如果竞争失败，开始进行偏向锁撤销。

![img](assets/JUC.assets/v2-5cba9488d16e0838e14c55b1aaf8819e_720w.webp)

偏向锁的撤销：

1. 偏向锁的撤销需要等待全局安全点（safe point，代表了一个状态，在该状态下所有线程都是暂停的，stop-the-world），到达全局安全点后，持有偏向锁的线程B也被暂停了。

2. 判断锁对象是否处于无锁状态，即获得偏向锁的线程如果已经退出了临界区，表示同步代码已经执行完了。重新竞争锁的线程会进行CAS操作替代原来线程的ThreadID。

3. 如果获得偏向锁的线程还处于临界区之内，表示同步代码还未执行完，将获得偏向锁的线程升级为轻量级锁。

一句话简单总结偏向锁原理：使用CAS操作将当前线程的ID记录到对象的Mark Word中。



##### **轻量级锁**

引入轻量级锁的目的：在多线程交替执行同步代码块时（未发生竞争），避免使用互斥量（重量锁）带来的性能消耗。但多个线程同时进入临界区（发生竞争）则会使得轻量级锁膨胀为重量级锁。

轻量级锁的获取流程：

- Java 虚拟机将在当前线程的栈帧创建锁记录（Lock Record）对象，每个线程的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的Mark Word

![image-20221113112700641](assets/JUC.assets/image-20221113112700641.png)

- 让锁记录中 Object reference 指向锁对象，并尝试用 cas 替换 Object 的 Mark Word，将 Mark Word 的值存入锁记录

![image-20221113112805880](assets/JUC.assets/image-20221113112805880.png)

- 如果 cas 替换成功，对象头中存储了 锁记录地址和状态 00 ，表示由该线程给对象加锁，这时图示如下

![image-20221113112844963](assets/JUC.assets/image-20221113112844963.png)

- 如果 cas 失败，有两种情况
  - 如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，该线程通过自旋尝试获得锁，即重复步骤2，自旋超过一定次数，轻量级锁升级为重量级锁。
  - 如果是自己执行了 synchronized 锁重入，那么再添加一条 Lock Record 作为重入的计数

![image-20221113112920145](assets/JUC.assets/image-20221113112920145.png)

轻量级锁的解锁：

- 当退出 synchronized 代码块（解锁时）如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减一

![image-20221113113226020](assets/JUC.assets/image-20221113113226020.png)

- 当退出 synchronized 代码块（解锁时）锁记录的值不为 null，**这时使用 cas 将 Lock Record中的 Mark Word 的值恢复给对象头**
  - 成功，则解锁成功
  - 失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程

一句话总结轻量级锁的原理：将对象的Mark Word复制到当前线程的Lock Record中，并将对象的Mark Word更新为指向Lock Record的指针。



**轻量级锁与偏向锁的比较**：

轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行 CAS 操作。

Java 6 中引入了偏向锁来做进一步优化：只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现

这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有





##### **锁膨胀**

如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁。

```java
	static Object obj = new Object();
	public static void method1() {
 		synchronized( obj ) {
 		// 同步块
 		}
	}
```

- 当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁

![image-20221113114238911](assets/JUC.assets/image-20221113114238911.png)

- 这时 Thread-1 加轻量级锁失败，进入锁膨胀流程
  - 即为 Object 对象申请 Monitor 锁，让 Object 指向重量级锁地址
  - 然后自己进入 Monitor 的 EntryList BLOCKED

![image-20221113114327245](assets/JUC.assets/image-20221113114327245.png)

- 当 Thread-0 退出同步块解锁时，使用 cas 将 Mark Word 的值恢复给对象头，失败。这时会进入重量级解锁流程，即按照 Monitor 地址找到 Monitor 对象，设置 Owner 为 null，唤醒 EntryList 中 BLOCKED 线程



##### 自旋锁

自旋锁的思路：如果持有锁的线程能在很短的时间内释放锁资源，那么那些**等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞、挂起状态**，只需等一等（也叫做自旋），在等待持有锁的线程释放锁后即可立即获取锁，这样就避免了用户线程在用户态和内核态之间的频繁切换而导致的时间消耗。

线程在自旋时会占用 CPU，在线程长时间自旋获取不到锁时，将会导致 CPU 的浪费。甚至有时线程永远无法获取锁而导致 CPU资源被永久占用，所以需要设定一个自旋等待的最大时间。在线程执行的时间超过自旋等待的最大时间后，线程会退出自旋模式并释放其持有的锁。

**1.自旋锁的优缺点**

优点：自旋锁可以减少 CPU 上下文的切换，对于占用锁的时间非常短或锁竞争不激烈的代码块来说性能大幅提升，因为自旋的 CPU 耗时明显少于线程阻塞、挂起、再唤醒时两次 CPU 上下文切换的耗时。

缺点：在持有锁的线程占用锁时间过长或锁的竞争过于激烈时，线程在自旋过程中会长时间获取不到锁资源，将引起 CPU 资源的浪费。所以在系统中有复杂锁依赖的情况下不适合采用自旋锁。

**2.自旋锁的时间阈值**

JDK 的不同版本所采用的自旋周期不同，JDK 1.5 为固定的时间，JDK 1.6 引入了适应性自旋锁。适应性自旋锁的自旋时间不再是固定值，而是由上一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的，可基本认为一个线程上下文切换的时间就是一个锁自旋的最佳时间。





#### **了解锁消除吗？**

锁消除是指Java虚拟机在即时编译时，通过对运行上下的扫描，**消除那些不可能存在共享资源竞争的锁**。锁消除可以节约无意义的请求锁时间。

#### **了解锁粗化吗？**

一般情况下，为了提高性能，总是将同步块的作用范围限制到最小，这样可以使得需要同步的操作尽可能地少。但如果一系列连续的操作一直对某个对象反复加锁和解锁，频繁地进行互斥同步操作也会引起不必要的性能消耗。

如果虚拟机检测到**有一系列操作都是对某个对象反复加锁和解锁**，会将加锁同步的范围粗化到整个操作序列的外部。可以看下面这个经典案例。

```java
for(int i=0;i<n;i++){
    synchronized(lock){
    }
}
```

这段代码会导致频繁地加锁和解锁，锁粗化后

```java
synchronized(lock){
    for(int i=0;i<n;i++){
    }
}
```



## AQS

**AQS（Abstract Queued Synchronized）是一个抽象的队列同步器，通过维护一个共享资源状态（Volatile Int State）和一个先进先出（FIFO）的线程等待队列来实现一个多线程访问共享资源的同步框架。**许多同步类的实现都依赖于 AQS，例如常用的 ReentrantLock、Semaphore 和 CountDownLatch。



#### AQS原理

AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。

```
CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node）来实现锁的分配。
```

看个AQS(AbstractQueuedSynchronizer)原理图：

![AQS原理图](assets/JUC.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Z2a5oyB5LiO5Yqq5Yqb,size_20,color_FFFFFF,t_70,g_se,x_16.png)


AQS使用一个 int 成员变量来表示同步状态，通过内置的FIFO队列来完成获取资源线程的排队工作。AQS使用CAS对该同步状态进行原子操作实现对其值的修改。

- private volatile int state;//共享变量，使用volatile修饰保证线程可见性

状态信息通过protected类型的getState，setState，compareAndSetState进行操作

```java
//返回同步状态的当前值
protected final int getState() {
        return state;
}
 // 设置同步状态的值
protected final void setState(int newState) {
        state = newState;
}
//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）
protected final boolean compareAndSetState(int expect, int update) {
        return unsafe.compareAndSwapInt(this, stateOffset, expect, update);
}
```



#### **AQS两种共享资源方式**

- Exclusive（独占式）：只有一个线程能执行，具体的 java 实现有 ReentrantLock，又可分为公平锁和非公平锁：

- Share（共享式）：多个线程可同时执行，具体的 java 实现有 Semaphore 和 CountDownLatch。


​	

#### AQS底层使用了模板方法模式

同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：

- 使用者继承AbstractQueuedSynchronizer并重写指定的方法。（这些重写方法很简单，无非是对于共享资源state的获取和释放）
- 将AQS组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。

这和我们以往通过实现接口的方式有很大区别，这是模板方法模式很经典的一个运用。

**AQS使用了模板方法模式，自定义同步器时需要重写下面几个AQS提供的模板方法：**

```java
isHeldExclusively()//该线程是否正在独占资源。只有用到condition才需要去实现它。
tryAcquire(int)//独占方式。尝试获取资源，成功则返回true，失败则返回false。
tryRelease(int)//独占方式。尝试释放资源，成功则返回true，失败则返回false。
tryAcquireShared(int)//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。
tryReleaseShared(int)//共享方式。尝试释放资源，成功则返回true，失败则返回false。
```

默认情况下，每个方法都抛出 UnsupportedOperationException。这些方法的实现必须是内部线程安全的，并且通常应该简短而不是阻塞。AQS类中的其他方法都是final ，所以无法被其他类使用，只有这几个方法可以被其他类使用。

以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。

再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS(Compare and Swap)减1。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。

一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。




## ReentrantLock

ReentrantLock 继承了 Lock 接口并实现了在接口中定义的方法，是一个**可重入的独占锁**。ReentrantLock 通过自定义队列同步器（Abstract Queued Synchronized，AQS）来实现锁的获取与释放。



#### ReentrantLock结构组成

![image-20221113235013197](assets/JUC.assets/image-20221113235013197.png)

**ReentrantLock** 类内部总共存在**Sync**、**NonfairSync**、**FairSync**三个类，**NonfairSync**与 **FairSync**类继承自 **Sync**类，**Sync**类继承自 **AbstractQueuedSynchronizer**抽象类。



#### ReentrantLock执行流程

锁的获取过程ReetrantLock.lock()：

1. 通过cas操作来修改state状态，表示争抢锁的操作，如果能够获取到锁，设置当前获得锁状态的线程。compareAndSetState(0, 1)

2. 如果没有获取到锁，尝试去获取锁。acquire(1)。

   2.1. 通过tryAcquire尝试获取独占锁，如果成功返回true，失败返回false。如果是同 一个线程来获得锁，则直接增加重入次数，并返回true。

   2.2. 如果tryAcquire失败，则会通过addWaiter方法将当前线程封装成Node，添加到AQS队列尾部

   2.3. acquireQueued，将Node作为参数，通过自旋去尝试获取锁。（如果前驱为head才有资格进行锁的抢夺。）

   ​		如果获取锁失败，则挂起线程。

锁的释放过程ReetrantLock.unlock()：

3. 尝试去释放锁。release(1)。

   3.1. tryRelease 方法将当前AQS中锁的状态 state-1，如果计算后的state仍然不等于0，意味着锁资源仍然没有被释放，那么不执行后续操作。

   3.2. 如果AQS中锁的状态为0，那么获取到当前AQS队列中的头结点。一般情况下只要唤醒后继结点的线程就行了，但是后继结点可能已经取消等待，所以从队列尾部往前回溯，找到离头结点最近的正常结点，并唤醒其线程。

在获得同步锁时，同步器维护一个同步队列，获取状态失败的线程都会被加入到队列中并在队列中进行自旋；移出队列（或停止自旋）的条件是前驱节点为头节点且成功获取了同步状态。在释放同步状态时，同步器调用tryRelease(int arg)方法释放同步状态，然后唤醒头节点的后继节点。

**NonfairSync源码：**

```java
//1.ReentrantLock获取锁
final void lock() {
    if (compareAndSetState(0, 1))
        setExclusiveOwnerThread(Thread.currentThread());
    else
        acquire(1);
}

//2.1 非公平锁 尝试获取锁
final boolean nonfairTryAcquire(int acquires) {
            final Thread current = Thread.currentThread();
            int c = getState();
            if (c == 0) {
                if (compareAndSetState(0, acquires)) {
                    setExclusiveOwnerThread(current);
                    return true;
                }
            }
            else if (current == getExclusiveOwnerThread()) {
                int nextc = c + acquires;
                if (nextc < 0) // overflow
                    throw new Error("Maximum lock count exceeded");
                setState(nextc);
                return true;
            }
            return false;
}


//3.ReentrantLock释放锁
public void unlock() {
     sync.release(1);
}

//3.1 Sync尝试释放锁
protected final boolean tryRelease(int releases) {
	int c = getState() - releases;
	if (Thread.currentThread() != getExclusiveOwnerThread())
		throw new IllegalMonitorStateException();
	boolean free = false;
    if (c == 0) {
    	free = true;
        setExclusiveOwnerThread(null);
    }
    setState(c);
    return free;
}
```

**AQS源码：**

```java
//2.获取锁+入队列
public final void acquire(int arg) {
    if (!tryAcquire(arg) &&
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}
//2.2 添加node
private Node addWaiter(Node mode) {
        Node node = new Node(Thread.currentThread(), mode);
        // Try the fast path of enq; backup to full enq on failure
        Node pred = tail;
        if (pred != null) {
            node.prev = pred;
            if (compareAndSetTail(pred, node)) {
                pred.next = node;
                return node;
            }
        }
        enq(node);
        return node;
}
//2.3 获取+阻塞 死循环
final boolean acquireQueued(final Node node, int arg) {
        boolean failed = true;
        try {
            boolean interrupted = false;
            for (;;) {
                final Node p = node.predecessor();
                if (p == head && tryAcquire(arg)) {
                    setHead(node);
                    p.next = null; // help GC
                    failed = false;
                    return interrupted;
                }
                if (shouldParkAfterFailedAcquire(p, node) &&
                    parkAndCheckInterrupt())
                    interrupted = true;
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
}

//3.释放锁+唤醒
public final boolean release(int arg) {
	if (tryRelease(arg)) {
    	Node h = head;
        if (h != null && h.waitStatus != 0)
        	unparkSuccessor(h);
        return true;
    }
    return false;
}

//3.2 唤醒
private void unparkSuccessor(Node node) {  
	// 获取当前节点的锁状态
    int ws = node.waitStatus;
	// 如果当前节点的锁状态小于0
    if (ws < 0)  
		// 通过CAS将当前节点的状态设为0 表示不会再产生后续影响
        compareAndSetWaitStatus(node, ws, 0);  
  	// 获取该节点的后继节点
    Node s = node.next;  
	// 如果后继节点为空或者也是一个失效的节点
    if (s == null || s.waitStatus > 0) {
		//将该后继节点设为null帮助垃圾回收
        s = null;  
		// AQS队列从尾节点开始向前遍历，找到一个有效节点
        for (Node t = tail; t != null && t != node; t = t.prev)  
            if (t.waitStatus <= 0)  
                s = t;  
    }  
	// 将找到的有效的后继节点的线程唤醒
    if (s != null)  
        LockSupport.unpark(s.thread);  
}
```



## synchronized与lock

#### **synchronized 与 ReentrantLock 的共同点**

- **都用于控制多线程多共享对象的访问。**
- **都是可重入锁**
- **都保证了可见性和互斥性**
  - synchronized 和 ReentrantLock（包括AQS的其他Lock），都能保证线程间的可见性，但实现方式有区别。**前者是通过虚拟机内部实现的，JAVA内存模型规定**，lock一个变量时需要清空工作内存的缓存，unlock一个变量时需要将工作内存同步回主内存中，synchronzied会遵守这个规定，因此可以保证线程间的可见性。
  - 后者是由于在 lock.lock() 和 lock.unlock() 时，都会操作 AbstractQueuedSynchronizer类 中的一个变量 state，**这个变量是 volatile 修饰的**，volatile变量的语句对应的汇编码指令中会多加一行lock addl $0x0, (%esp)，这一行的作用是：（1）将工作内存修改了的缓存（不仅仅是该变量的缓存）都强制刷新回主内存（2）把其他CPU对应缓存行标记为invalid状态，那么在读取这一部分缓存时，必须回主内存读取。这样也就保证了线程间的可见性。



####  **synchronized与lock的区别**

**1、Lock是java实现的，synchronized是JVM层面实现的**

**2、Lock是接口，synchronized是关键字**

**3、Lock可以判断是否获取锁 而synchronized不能**

**4、Lock需要手动释放锁，而synchronized不需要**

**5、Lock在等待时可中断或不可中断，而synchronized无法中断**

**6、Lock可重入锁，可以公平也可以不公平，synchronized可重入锁，非公平**

**7、Synchronized可以锁类 锁方法 锁代码块 而Lock只可以锁代码块**





#### **synchronized 与 Lock 的使用场景**

**Synchronized 适用于少量代码同步的情况下，性能开销比较大。Lock 锁适用于大量同步阶段**：

- Lock 锁可以提高多个线程进行读的效率(使用 readWriteLock)

- 在竞争不是很激烈的情况下，Synchronized的性能要优于ReetrantLock，但是**在资源竞争很激烈的情况下，Synchronized的性能会下降几十倍，但是ReetrantLock的性能能维持常态**；

- **ReetrantLock 提供了多样化的同步，比如有时间限制的同步，可以被Interrupt的同步**（synchronized的同步是不能Interrupt的）等。





## **Semaphore**

**Semaphore 是一种基于计数的信号量。ReentrantLock 是AQS的独占式实现, Semaphore 是AQS的共享式实现**。在定义信号量对象时可以设定一个阈值，基于该阈值，多个线程竞争获取许可信号，线程在竞争到许可信号后开始执行具体的业务逻辑，业务逻辑在执行完成后释放该许可信号。在许可信号的竞争队列超过阈值后，新加入的申请许可信号的线程将被阻塞，直到有其他许可信号被释放。

**Semaphore 可以用于实现一些对象池、资源池的构建，比如静态全局对象池、数据库连接池等。常应用于多个线程共享有限资源的情况**

#### **基本使用**

```java
public static void main(String[] args) {
	// 1. 创建 一个计数阈值为3的 semaphore 对象，即只能有3个线程勇士访问
 	Semaphore semaphore = new Semaphore(3);
 	// 2. 10个线程同时运行
 	for (int i = 0; i < 10; i++) {
 		new Thread(() -> {
 		// 3. 获取许可
 		try {
 			semaphore.acquire();
 		} catch (InterruptedException e) {
 			e.printStackTrace();
 		}
		finally {
 			// 4. 释放许可
 			semaphore.release();
 		}
 		}).start();
 	}
 }
```

#### **Semaphore** **应用**

- 使用 Semaphore 限流，在访问高峰期时，让请求线程阻塞，高峰期过去再释放许可，当然它只适合限制单机

  线程数量，并且仅是限制线程数，而不是限制资源数（例如连接数，请对比 Tomcat LimitLatch 的实现）

- 用 Semaphore 实现简单连接池，对比『享元模式』下的实现（用wait notify），性能和可读性显然更好，

  注意下面的实现中线程数和数据库连接数是相等的

```java
@Slf4j(topic = "c.Pool")
class Pool {
 	// 1. 连接池大小
 	private final int poolSize;
 	// 2. 连接对象数组
 	private Connection[] connections;
 	// 3. 连接状态数组 0 表示空闲， 1 表示繁忙
 	private AtomicIntegerArray states;
 	private Semaphore semaphore;
     // 4. 构造方法初始化
 	public Pool(int poolSize) {
 		this.poolSize = poolSize;
 		// 让许可数与资源数一致
 		this.semaphore = new Semaphore(poolSize);
 		this.connections = new Connection[poolSize];
 		this.states = new AtomicIntegerArray(new int[poolSize]);
 		for (int i = 0; i < poolSize; i++) {
 			connections[i] = new MockConnection("连接" + (i+1));
 		}
 	}
 	// 5. 借连接
 	public Connection borrow() {// t1, t2, t3
 		// 获取许可
 		try {
 		semaphore.acquire(); // 没有许可的线程，在此等待
 		} catch (InterruptedException e) {
 			e.printStackTrace();
 		}
 		for (int i = 0; i < poolSize; i++) {
 			// 获取空闲连接
 			if(states.get(i) == 0) {
 				if (states.compareAndSet(i, 0, 1)) {
 					log.debug("borrow {}", connections[i]);
 					return connections[i];
 				}
 			}
 		}
 		// 不会执行到这里
 		return null;
 	}
 	// 6. 归还连接
 	public void free(Connection conn) {
 		for (int i = 0; i < poolSize; i++) {
 			if (connections[i] == conn) {
 				states.set(i, 0);
 				log.debug("free {}", conn);
 				semaphore.release();
 				break;
 			}
 		}
 	}
}
```

#### Semaphore 原理

**Semaphore**与ReentrantLock的内部类的结构相同，总共存在**Sync**、**NonfairSync**、**FairSync**三个类，**NonfairSync**与 **FairSync**类继承自 **Sync**类，**Sync**类继承自 **AbstractQueuedSynchronizer**抽象类。获取锁与释放锁的具体实现有点差别

锁的获取过程Semaphore.acquire()：

1. 尝试去获取锁。acquire()。

   2. 通过tryAcquireShared尝试获取共享锁，将当前AQS中锁的状态 state-1，如果 < 0 或者 CAS 成功则返回 ，如果返回值 >=0 获取锁成功，否则 tryAcquireShared 失败。

   3. 如果 tryAcquireShared 失败

      ​	3.1.通过addWaiter方法将当前线程封装成Node，添加到AQS队列尾部

      ​    3.2.tryAcquireShared，通过自旋去尝试获取共享锁。（如果前驱为head才有资格进行锁的抢夺。）

   
   ​		   如果获取锁失败，则挂起线程。

锁的释放过程Semaphore.release()：

4. 尝试去释放锁。release(1)。

   4.1. tryReleaseShared 方法通过 CAS 将当前AQS中锁的状态 state+1，直到成功。

   4.2. doReleaseShared 方法唤醒后继结点的线程，其中用到 CAS 改变头节点的状态，为了防止多个线程同时唤醒。



```java
// 1.NonfairSync 获取锁
public void acquire() throws InterruptedException {
 	sync.acquireSharedInterruptibly(1);
}

// 2 获取锁 + 入队列
public final void acquireSharedInterruptibly(int arg) throws InterruptedException {
	if (Thread.interrupted())
 		throw new InterruptedException();
 	if (tryAcquireShared(arg) < 0)
 		doAcquireSharedInterruptibly(arg);
}
// 2.1 尝试获取锁
final int nonfairTryAcquireShared(int acquires) {
 	for (;;) {
 		int available = getState();
 		int remaining = available - acquires; 
 		if (remaining < 0 ||compareAndSetState(available, remaining)) {
 			return remaining;
 		}
 	}
}
// 3 添加node 获取+阻塞 死循环
private void doAcquireSharedInterruptibly(int arg) throws InterruptedException {
 	final Node node = addWaiter(Node.SHARED);	// 3.1.通过addWaiter方法将当前线程封装成Node
 	boolean failed = true;
 	try {
 		for (;;) {
            final Node p = node.predecessor();
            if (p == head) {
            // 3.2 再次尝试获取许可
                int r = tryAcquireShared(arg);
                if (r >= 0) {
                    // 成功后本线程出队（AQS）, 所在 Node设置为 head
                    // 如果 head.waitStatus == Node.SIGNAL ==> 0 成功, 下一个节点 unpark
                    // 如果 head.waitStatus == 0 ==> Node.PROPAGATE 
                    // r 表示可用资源数, 为 0 则不会继续传播
                    setHeadAndPropagate(node, r);
                    p.next = null; // help GC
                    failed = false;
                    return;
                }
            }
            // 不成功, 设置上一个节点 waitStatus = Node.SIGNAL, 下轮进入 park 阻塞
            if (shouldParkAfterFailedAcquire(p, node) &&
                parkAndCheckInterrupt())
                throw new InterruptedException();
 		}
 	} finally {
 		if (failed)
 			cancelAcquire(node);
 	}
 }


// 4. 释放锁
public void release() {
	sync.releaseShared(1);
}
 
public final boolean releaseShared(int arg) {
	if (tryReleaseShared(arg)) {
 		doReleaseShared();
 		return true;
 	}
 	return false;   //用不到
}

// 4.1 尝试释放锁
protected final boolean tryReleaseShared(int releases) {
	for (;;) {
 		int current = getState();
 		int next = current + releases;
 		if (next < current) // overflow
 			throw new Error("Maximum permit count exceeded");
 		if (compareAndSetState(current, next))
 			return true;
 	}
}

// 4.2 唤醒后继节点
private void doReleaseShared() {
	for (;;) {
    	Node h = head;
        if (h != null && h != tail) {
        	int ws = h.waitStatus;
            if (ws == Node.SIGNAL) {
            	if (!h.compareAndSetWaitStatus(Node.SIGNAL, 0))
                	continue;            // loop to recheck cases
                unparkSuccessor(h);
            }
            else if (ws == 0 &&
                     !h.compareAndSetWaitStatus(0, Node.PROPAGATE))
            	continue;                // loop on failed CAS
       	}
        if (h == head)                   // loop if head changed
        	break;
    }
}
```



## CountDownLatch

CountDownLatch 位于 java.util.concurrent 包下，**一个同步工具类，基于线程计数器来实现并发访问控制**，允许一个或多个线程一起等待其他线程的操作执行完毕后再执行相关操作，**例如用于主线程等待其他子线程都执行完毕后再执行相关操作**。其使用过程：再主线程中定义 CountDownLatch，并将线程计数器的初始值设置为子线程的个数，多个子线程并发执行，每一个子线程在执行完毕后都会调用 countDown 函数将计数器的值减 1，直到线程计数器为 0，表示所有的子线程任务都执行完毕，此时在 CountDownLatch 上等待的主线程将被唤醒并继续执行。



**应用之同步等待多线程准备完毕**

```java
    AtomicInteger num = new AtomicInteger(0);
    ExecutorService service = Executors.newFixedThreadPool(10, (r) -> {
         return new Thread(r, "t" + num.getAndIncrement());
    });
    CountDownLatch latch = new CountDownLatch(10); /***/
    String[] all = new String[10];
    Random r = new Random();
    for (int j = 0; j < 10; j++) {
        int x = j;
        service.submit(() -> {
            for (int i = 0; i <= 100; i++) {
                try {
                    Thread.sleep(r.nextInt(100));
                } catch (InterruptedException e) {
                }
                all[x] = Thread.currentThread().getName() + "(" + (i + "%") + ")";
                System.out.print("\r" + Arrays.toString(all));
            }
            latch.countDown(); /***/
        });
    }
    latch.await(); /***/
    System.out.println("\n游戏开始...");
    service.shutdown();
```



## CyclicBarrier

**CyclicBarrier （循环屏障）是一个同步工具，可以实现让一组线程等待至某状态之后再全部同时执行。**在所有等待线程都被释放之后，CyclicBarrier 可被重用。构造时设置『计数个数』，每个线程执行到某个需要“同步”的时刻调用 await() 方法进行等待，当等待的线程数满足『计数个数』时，继续执行

```java
    CyclicBarrier cb = new CyclicBarrier(2); // 个数为2时才会继续执行
    new Thread(()->{
        System.out.println("线程1开始.."+new Date());
        try {
            cb.await(); // 当个数不足时，等待
        } catch (InterruptedException | BrokenBarrierException e) {
            e.printStackTrace();
        }
        System.out.println("线程1继续向下运行..."+new Date());
    }).start();
    new Thread(()->{
        System.out.println("线程2开始.."+new Date());
        try { Thread.sleep(2000); } catch (InterruptedException e) { }
        try {
            cb.await(); // 2 秒后，线程个数够2，继续运行
        } catch (InterruptedException | BrokenBarrierException e) {
            e.printStackTrace();
        }
        System.out.println("线程2继续向下运行..."+new Date());
    }).start();
```





# Java 中的阻塞队列
## 什么是阻塞队列

阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。

这两个附加的操作支持阻塞的插入和移除方法。

- 支持阻塞的插入方法：意思是当队列满时，队列会阻塞插入元素的线程，直到队列不满。

- 支持阻塞的移除方法：意思是在队列为空时，获取元素的线程会等待队列变为非空。

​        阻塞队列常用于生产者和消费者的场景，生产者是向队列里添加元素的线程，消费者是从队列里取元素的线程。阻塞队列就是生产者用来存放元素、消费者用来获取元素的容器。


![img](assets/JUC.assets/a9ecd240a0fd47518f34b31e3a34ada9.png)

- 抛出异常：当队列满时，如果再往队列里插入元素，会抛出 IllegalStateException （"Queue full"）异常。当队列空时，从队列里获取元素会抛出 NoSuchElementException 异常。
- 返回特殊值：当往队列插入元素时，会返回元素是否插入成功，成功返回 true。 如果是移除方法，则是从队列里取出一个元素，如果没有则返回 null。
- 一直阻塞：当阻塞队列满时，如果生产者线程往队列里 put 元素，队列会一直阻塞生产者线程，直到队列可用或者响应中断退出。当队列空时，如果消费者线程从队列里 take 元素，队列会阻塞住消费者线程，直到队列不为空。
- 超时退出：当阻塞队列满时，如果生产者线程往队列里插入元素，队列会阻塞生产者线程一段时间，如果超过了指定的时间，生产者线程就会退出。
- 如果是无界阻塞队列，队列不可能会出现满的情况，所以使用 put 或 offer 方法永远不会被阻塞，而且使用 offer 方法时，该方法永远返回 true。

##  7 个阻塞队列

#### ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列。

​        ArrayBlockingQueue 是一个用数组实现的有界阻塞队列。此队列按照先进先出 （FIFO）的原则对元素进行排序。默认情况下不保证线程公平的访问队列。

```java
// 访问者的公平性是使用可重入锁实现的。
public ArrayBlockingQueue(int capacity, boolean fair) {
     if (capacity <= 0) throw new IllegalArgumentException();
     this.items = new Object[capacity];
     lock = new ReentrantLock(fair);
     notEmpty = lock.newCondition();
     notFull = lock.newCondition();
}
```

#### LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列。

​        LinkedBlockingQueue 是一个用链表实现的有界阻塞队列。此队列的默认和最大长度为 Integer.MAX_VALUE。此队列按照先进先出的原则对元素进行排序。 

#### PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。

​        PriorityBlockingQueue 是一个支持优先级的无界阻塞队列。默认情况下元素采取自然顺序升序排列。也可以自定义类实现 compareTo()方法来指定元素排序规则，或者初始化 PriorityBlockingQueue 时，指定构造参数 Comparator 来对元素进行排序。需要注意的是不能保证同优先级元素的顺序。 

#### DelayQueue：一个使用优先级队列实现的无界阻塞队列。

​         DelayQueue 是一个**支持延时获取元素的无界阻塞队列**。队列使用 PriorityQueue 来实现。**队列中的元素必须实现 Delayed 接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。**

   DelayQueue 运用在以下应用场景。

- 缓存系统的设计：可以用 DelayQueue 保存缓存元素的有效期，使用一个线程循环查询 DelayQueue，一旦能从 DelayQueue 中获取元素时，表示缓存有效期到了。
- 定时任务调度：使用 DelayQueue 保存当天将会执行的任务和执行时间，一旦从 DelayQueue 中获取到任务就开始执行，比如 TimerQueue 就是使用 DelayQueue 实现的。

实现 Delayed 接口，ScheduledThreadPoolExecutor 里 ScheduledFutureTask 类的实现

```java
private static final AtomicLong sequencer = new AtomicLong(0);
ScheduledFutureTask(Runnable r, V result, long ns, long period){
     super(r, result);
     // 使用 time 记录当前对象延迟到什么时候可以使用
     this.time = ns;
     this.period = period;
     // 使用 sequenceNumber 来标识元素在队列中的先后顺序
     this.sequenceNumber = sequencer.getAndIncrement();
 }
/*延迟时间参数 ns 的单位是纳秒，自己设计的时候最好使用纳秒，
因为实现 getDelay()方法时可以指定任意单位，一旦以秒或分作为单位，而延时时间
又精确不到纳秒就麻烦了。
使用时请注意当 time 小于当前时间时，getDelay 会返回负数。*/
// 实现 getDelay 方法，该方法返回当前元素还需要延时多长时间，单位是纳秒
public long getDelay(TimeUnit unit) {
 return unit.convert(time - now(), TimeUnit.NANOSECONDS);
}
// 实现 compareTo 方法来指定元素的顺序。例如，让延时时间最长的放在队列的末尾。
public int compareTo(Delayed other) {
     if (other == this)// compare zero ONLY if same object
     return 0;
     if (other instanceof ScheduledFutureTask) {
         ScheduledFutureTask<> x = (ScheduledFutureTask<>) other; long diff = time - x.time;
         if (diff < 0) return -1;
         else if (diff > 0) return 1;
         else if (sequenceNumber < x.sequenceNumber) return -1;
         else return 1;
     }
     long d = (getDelay(TimeUnit.NANOSECONDS) other.getDelay(TimeUnit.NANOSECONDS));
     return (d == 0) ? 0 : ((d < 0) ? -1 : 1);
}
```

 实现延时阻塞队列

```java
// 当消费者从队列里获取元素时，如果元素没有达到延时时间，就阻塞当前线程
long delay = first.getDelay(TimeUnit.NANOSECONDS);
if (delay <= 0) return q.poll();
else if (leader != null) available.await();
else {
     Thread thisThread = Thread.currentThread();
     leader = thisThread;
     try {
         available.awaitNanos(delay);
     } finally {
         if (leader == thisThread) leader = null;
     }
}
/*变量 leader 是一个等待获取队列头部元素的线程。
如果 leader 不等于空，表示已经有线程在等待获取队列的头元素。
使用 await()方法让当前线程等待信号。
如果 leader 等于空，则把当前线程设置成 leader，
并使用awaitNanos()方法让当前线程等待接收信号或等待 delay 时间。*/
```

#### SynchronousQueue：一个不存储元素的阻塞队列。

​         每一个 put 操作必须等待一个 take 操作，否则不能继续添加元素。 它支持公平访问队列。默认情况下线程采用非公平性策略访问队列。使用以下构造方法可以创建公平性访问的 SynchronousQueue，如果设置为 true，则等待的线程会采用 先进先出的顺序访问队列。

```java
public SynchronousQueue(boolean fair) { 
transferer = fair ? new TransferQueue() : new TransferStack(); 
}
```

SynchronousQueue可以看成是一个传球手，负责把生产者线程处理的数据直接传递给消费者线程。队列本身并不存储任何元素，非常适合传递性场景。SynchronousQueue 的吞吐量高于 LinkedBlockingQueue 和 ArrayBlockingQueue。

#### LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。

LinkedTransferQueue 是一个由链表结构组成的无界阻塞 TransferQueue 队列。相对于 其他阻塞队列，LinkedTransferQueue 多了 tryTransfer 和 transfer 方法。

transfer 方法

```java
/*如果当前有消费者正在等待接收元素（消费者使用 take()方法或带时间限制的poll()
方法时），transfer 方法可以把生产者传入的元素立刻 transfer（传输）给消费者。
如果没有消费者在等待接收元素，transfer 方法会将元素存放在队列的 tail 节点，
并等到该元素被消费者消费了才返回*/
// 试图把存放当前元素的 s 节点作为 tail 节点
Node pred = tryAppend(s, haveData);
/* CPU 自旋等待消费者消费元素。
因为自旋会消耗 CPU，所以自旋一定的次数后
使用Thread.yield()方法来暂停当前正在执行的线程，并执行其他线程。*/
return awaitMatch(s, pred, e, (how == TIMED), nanos);
```

tryTransfer 方法

​	tryTransfer 方法是**用来试探生产者传入的元素是否能直接传给消费者。**

- 如果没有消费者等待接收元素，则返回 false。和 transfer 方法的区别是 tryTransfer 方法无论消费者是否接收，方法立即返回，而 transfer 方法是必须等到消费者消费了才返回。

- 对于带有时间限制的 tryTransfer（E e，long timeout，TimeUnit unit）方法，试图把生产者传入的元素直接传给消费者，但是如果没有消费者消费该元素则等待指定的时间 再返回，如果超时还没消费元素，则返回 false，如果在超时时间内消费了元素，则返回 true。 

#### LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。

​        LinkedBlockingDeque 是一个由链表结构组成的双向阻塞队列。

​		所谓双向队列指的是可以从队列的两端插入和移出元素。双向队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。相比其他的阻塞队列，LinkedBlockingDeque 多了 addFirst、addLast、offerFirst、offerLast、peekFirst 和 peekLast 等方法，以 First 单词结尾 的方法，表示插入、获取（peek）或移除双端队列的第一个元素。以 Last 单词结尾的方 法，表示插入、获取或移除双端队列的最后一个元素。

另外，插入方法 add 等同于 addLast，移除方法 remove 等效于 removeFirst。但是 take 方法却等同于 takeFirst，使用时还是用带有 First 和 Last 后缀的方法更清楚。

在初始化 LinkedBlockingDeque 时可以设置容量防止其过度膨胀。另外，双向阻塞队 列可以运用在“工作窃取”模式中。
