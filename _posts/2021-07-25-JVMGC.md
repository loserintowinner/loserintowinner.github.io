---
layout: post
title:  【JAVA】GC优化常用手段
---

## 1. 降低进入老年代的对象数量

除了可以在JDK 7及更高版本中使用的G1收集器以外，其他分代GC都是由Oracle JVM提供的。

关于分代GC，就是对象在Eden区被创建，随后被转移到Survivor区，在此之后剩余的对象会被转入老年代。也有一些对象由于占用内存过大，在Eden区被创建后会直接被传入老年代。

老年代GC相对来说会比新生代GC更耗时，因此，减少进入老年代的对象数量可以显著降低Full GC的频率。你可能会以为减少进入老年代的对象数量意味着把它们留在新生代，事实正好相反，新生代内存的大小是可以调节的。

实际项目中根据 GC 日志分析新生代空间大小分配是否合理，适当通过“**-Xmn**”命令调节新生代大小，最大限度降低新对象直接进入老年代的情况。

## 2. 降低Full GC的时间

Full GC的执行时间比Minor GC要长很多，因此，如果在Full GC上花费过多的时间（超过1s），将可能出现超时错误。

如果通过减小老年代内存来减少Full GC时间，可能会引起`OutOfMemoryError`或者导致Full GC的频率升高。

另外，如果通过增加老年代内存来降低Full GC的频率，Full GC的时间可能因此增加。

因此，你需要把老年代的大小设置成一个“合适”的值。

## 3. 常用调整参数

- **Xms 是指设定程序启动时占用内存大小(初始化堆大小)**

  一般来讲，这个值大点，程序会启动的快一点，但是也可能会导致机器暂时间变慢。

- **Xmx 是指设定程序运行期间最大可占用的内存大小(最大堆大小)**

  如果程序运行需要占用更多的内存，超出了这个设置值，就会抛出OutOfMemory异常。

- **Xss 是指设定每个线程的堆栈大小**

  这个就要依据你的程序，看一个线程大约需要占用多少内存，可能会有多少线程同时运行等。